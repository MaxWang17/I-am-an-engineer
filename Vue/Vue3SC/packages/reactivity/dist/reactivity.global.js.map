{"version":3,"file":"reactivity.global.js","sources":["../../shared/src/index.ts","../src/effect.ts","../src/baseHandlers.ts","../src/reactive.ts"],"sourcesContent":["const isObject = (value)=> typeof value == 'object' && value !== null\r\nconst extend = Object.assign\r\nconst isArray = Array.isArray\r\nconst isFunction = (value)=> typeof value == 'function'\r\nconst isNumber = (value)=> typeof value == 'number'\r\nconst isString = (value)=> typeof value == 'string'\r\nconst isIntegerKey = (key)=> parseInt(key) + '' === key\r\nconst hasOwn = (target,key)=> Object.prototype.hasOwnProperty.call(target,key)\r\nconst hasChanged = (oldValue,value) => oldValue !== value\r\n\r\nexport{\r\n    isObject,\r\n    extend,\r\n    isArray,\r\n    isFunction,\r\n    isNumber,\r\n    isString,\r\n    isIntegerKey,\r\n    hasOwn,\r\n    hasChanged\r\n}","export function effect(fn, options: any = {}) {\r\n  // 我需要effect变成响应式的，数据变化可以重新执行\r\n  const effect = createReactiveEffect(fn, options);\r\n\r\n  if (!options.lazy) {\r\n    // 利用配置的lazy属性\r\n    effect(); // 响应式的effect会默认先执行一次\r\n  }\r\n\r\n  return effect;\r\n}\r\n\r\nlet uid = 0;\r\nlet activeEffect; // 存储当前正在运行的effect\r\nconst effectStack = []; // 存储用的栈\r\nfunction createReactiveEffect(fn, options) {\r\n  const effect = function reactiveEffect() {\r\n    if (!effectStack.includes(effect)) {\r\n      // 保证effect不在栈里才执行\r\n      // 函数执行可能报错，所以用try-finally兜底一下\r\n      try {\r\n        effectStack.push(effect);\r\n        activeEffect = effect; // 头秃写法\r\n        return fn();\r\n      } finally {\r\n        // 不管有无异常都执行\r\n        effectStack.pop();\r\n        activeEffect = effectStack[effectStack.length - 1];\r\n      }\r\n    }\r\n  };\r\n  effect.id = uid++; // 制作一个effect标识，用于区分effect\r\n  effect._isEffect = true; // 用于标识这个是响应式effect\r\n  effect.row = fn; // 保留effect对应的原函数\r\n  effect.options = options; // 在effect上保存用户的属性\r\n  return effect;\r\n}\r\n\r\n// 让，某个对象中的属性，收集当前它对应的effect\r\nconst targetMap = new WeakMap();\r\nexport function track(target, type, key) {\r\n  // activeEffect; // 关联已创建，你学废了吗\r\n  if (activeEffect === undefined) {\r\n    // 此属性不用收集依赖，因为没在effect中使用\r\n    return;\r\n  }\r\n  let depsMap = targetMap.get(target);\r\n  if (!depsMap) {\r\n    //初次取值找不到\r\n    targetMap.set(target, (depsMap = new Map()));\r\n  }\r\n  let dep = depsMap.get(key);\r\n  if (!dep) {\r\n    depsMap.set(key, (dep = new Set()));\r\n  }\r\n  if (!dep.has(activeEffect)) {\r\n    dep.add(activeEffect);\r\n  }\r\n  console.log(targetMap,\"勇敢的少年快去创造奇迹\")\r\n}\r\n\r\n// 需求场景1：\r\n// 以下是头秃写法的坑，为了解决这种顺序错乱的问题，要搞个栈做处理（先进后出，弹夹）\r\n// 原理：函数调用是是个栈型结构\r\n// effect(()=>{ // effect1\r\n//     state.name // => effect1\r\n//     effect(()=>{ // effect2\r\n//         state.age // => effect2\r\n//     })\r\n//     state.sex // 按逻辑应该是effect1，但是如果没有一个栈做处理，就会变成effect2了\r\n// })\r\n\r\n// 需求场景2：\r\n// 如果对于effect是否已入栈不检查，以下就会出现死循环\r\n// effect(()=>{\r\n//     state.xxx++\r\n// })\r\n","// 实现关键的Handelr，里面有get、有set\r\n\r\nimport { extend, isArray, isObject } from \"@vue/shared/src\";\r\nimport { track } from \"./effect\";\r\nimport { TrackOpTypes } from \"./operators\";\r\nimport { reactive, readonly } from \"./reactive\";\r\n\r\n// 考虑1：是不是仅读，仅读的属性set时会报异常\r\n// 考虑2：是不是深度\r\n\r\nlet readonlyObj = {\r\n  set: (target, key) => {\r\n    console.warn(`set on key  ${key} failed`);\r\n  },\r\n};\r\n\r\nconst get = createGetter();\r\nconst shallowGet = createGetter(false, true);\r\nconst readonlyGet = createGetter(true);\r\nconst shallowReadonlyGet = createGetter(true, true);\r\nconst set = createSetter();\r\nconst shallowSet = createSetter(true);\r\n\r\nconst mutableHandlers = {\r\n  get,\r\n};\r\n\r\nconst shallowReactiveHandlers = {\r\n  get: shallowGet,\r\n};\r\n\r\nconst readonlyHandlers = extend(\r\n  {\r\n    get: readonlyGet,\r\n  },\r\n  readonlyObj\r\n);\r\n\r\nconst shallowReadonlyHandlers = extend(\r\n  {\r\n    get: shallowReadonlyGet,\r\n  },\r\n  readonlyObj\r\n);\r\n\r\nexport {\r\n  mutableHandlers,\r\n  shallowReactiveHandlers,\r\n  readonlyHandlers,\r\n  shallowReadonlyHandlers,\r\n};\r\n\r\nfunction createGetter(isReadonly = false, isShallow = false) {\r\n  // 核心拦截方法\r\n  return function get(target, key, receiver) {\r\n    // let proxy = reactivee()\r\n    // proxy + reflect(后续obiect上的方法会被迁移到reflect)\r\n    // 在以前，target[key] = vlaue 可能会失败（如果target只读），并不会报异常，也没有返回值标识\r\n    // reflect方法具备返回值\r\n\r\n    const res = Reflect.get(target, key, receiver);\r\n\r\n    if(!isReadonly){\r\n        // 收集依赖，会等数据变化后更新对应的视图\r\n        console.log(\"收集effect\",new Date)\r\n        track(target,TrackOpTypes.GET,key) // TrackOpTypes.GET目前只是一个标识\r\n    }\r\n\r\n    if(isShallow){\r\n        return res\r\n    }\r\n\r\n    if(isObject(res)){ // vue2 是一上来就递归，vue3 是当取值时会进行代理。vue3的代理模式是懒代理。\r\n        return isReadonly ? readonly(res):reactive(res)\r\n    }\r\n\r\n    return res;\r\n  };\r\n}\r\nfunction createSetter(isShallow = false) {\r\n  // 核心设置方法\r\n  return function set(target, key, value, receiver) {\r\n    const res = Reflect.set(target, key, value, receiver);\r\n\r\n    // 当数据更新时，通知对应属性的effect重新执行\r\n\r\n    // 我们要区分是新增还是修改的。vue2里无法监控更改索引，无法监控数组长度变化；vue3都解决了。但其中还是有hack的方法，需要特殊处理。\r\n    const oldValue = target[key]; // 获取老的值\r\n\r\n\r\n\r\n    return res;\r\n  };\r\n}\r\n","import { isObject } from \"@vue/shared/src\"\r\nimport {\r\n    mutableHandlers,\r\n    shallowReactiveHandlers,\r\n    readonlyHandlers,\r\n    shallowReadonlyHandlers,\r\n} from './baseHandlers'\r\n\r\n\r\n\r\nexport function reactive(target) {\r\n    return createReactiveObject(target, false, mutableHandlers)\r\n}\r\nexport function shallowReactive(target) {\r\n    return createReactiveObject(target, false, shallowReactiveHandlers)\r\n}\r\nexport function readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers)\r\n}\r\nexport function shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers)\r\n}\r\n\r\n// 是不是只读，是不是深度。完全可以用参数配置，所以考虑柯里化，公用同一个方法（省的写四遍）\r\n// vue3响应式底层核心原理是：new Proxy  其本质还是操作get和set\r\nconst reactiveMap = new WeakMap(); // 会自动垃圾回收，不会造成内存泄露，存储的key只能是对象\r\nconst readonlyMap = new WeakMap();\r\nexport function createReactiveObject(target, isReadonly, baseHanelers) {\r\n    // 如果目标不是对象，没法拦截了，reactive这个api只能拦截对象类型\r\n    if (!isObject(target)) {\r\n        return target\r\n    }\r\n\r\n    // 如果某个对象已经被代理，就不要再次代理\r\n    const proxyMap = isReadonly ? readonlyMap : reactiveMap\r\n    const exisProxy = proxyMap.get(target)\r\n    if (exisProxy) {\r\n        return exisProxy\r\n    }\r\n    // 发现未被代理，那么代理一下，并存储到map里以备查询\r\n    const proxy = new Proxy(target, baseHanelers);\r\n    proxyMap.set(target, proxy) // 将要代理的对象和对应的代理结果缓存起来\r\n\r\n    return proxy;\r\n}\r\n"],"names":[],"mappings":"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"}