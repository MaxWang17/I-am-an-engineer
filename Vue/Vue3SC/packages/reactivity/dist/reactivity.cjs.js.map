{"version":3,"file":"reactivity.cjs.js","sources":["../../shared/src/index.ts","../src/effect.ts","../src/baseHandlers.ts","../src/reactive.ts"],"sourcesContent":["const isObject = (value)=> typeof value == 'object' && value !== null\r\nconst extend = Object.assign\r\nconst isArray = Array.isArray\r\nconst isFunction = (value)=> typeof value == 'function'\r\nconst isNumber = (value)=> typeof value == 'number'\r\nconst isString = (value)=> typeof value == 'string'\r\nconst isIntegerKey = (key)=> parseInt(key) + '' === key\r\nconst hasOwn = (target,key)=> Object.prototype.hasOwnProperty.call(target,key)\r\nconst hasChanged = (oldValue,value) => oldValue !== value\r\n\r\nexport{\r\n    isObject,\r\n    extend,\r\n    isArray,\r\n    isFunction,\r\n    isNumber,\r\n    isString,\r\n    isIntegerKey,\r\n    hasOwn,\r\n    hasChanged\r\n}","export function effect(fn, options: any = {}) {\r\n  // 我需要effect变成响应式的，数据变化可以重新执行\r\n  const effect = createReactiveEffect(fn, options);\r\n\r\n  if (!options.lazy) {\r\n    // 利用配置的lazy属性\r\n    effect(); // 响应式的effect会默认先执行一次\r\n  }\r\n\r\n  return effect;\r\n}\r\n\r\nlet uid = 0;\r\nlet activeEffect; // 存储当前正在运行的effect\r\nconst effectStack = []; // 存储用的栈\r\nfunction createReactiveEffect(fn, options) {\r\n  const effect = function reactiveEffect() {\r\n    if (!effectStack.includes(effect)) {\r\n      // 保证effect不在栈里才执行\r\n      // 函数执行可能报错，所以用try-finally兜底一下\r\n      try {\r\n        effectStack.push(effect);\r\n        activeEffect = effect; // 头秃写法\r\n        return fn();\r\n      } finally {\r\n        // 不管有无异常都执行\r\n        effectStack.pop();\r\n        activeEffect = effectStack[effectStack.length - 1];\r\n      }\r\n    }\r\n  };\r\n  effect.id = uid++; // 制作一个effect标识，用于区分effect\r\n  effect._isEffect = true; // 用于标识这个是响应式effect\r\n  effect.row = fn; // 保留effect对应的原函数\r\n  effect.options = options; // 在effect上保存用户的属性\r\n  return effect;\r\n}\r\n\r\n// 让，某个对象中的属性，收集当前它对应的effect\r\nconst targetMap = new WeakMap();\r\nexport function track(target, type, key) {\r\n  // activeEffect; // 关联已创建，你学废了吗\r\n  if (activeEffect === undefined) {\r\n    // 此属性不用收集依赖，因为没在effect中使用\r\n    return;\r\n  }\r\n  let depsMap = targetMap.get(target);\r\n  if (!depsMap) {\r\n    //初次取值找不到\r\n    targetMap.set(target, (depsMap = new Map()));\r\n  }\r\n  let dep = depsMap.get(key);\r\n  if (!dep) {\r\n    depsMap.set(key, (dep = new Set()));\r\n  }\r\n  if (!dep.has(activeEffect)) {\r\n    dep.add(activeEffect);\r\n  }\r\n  console.log(targetMap,\"勇敢的少年快去创造奇迹\")\r\n}\r\n\r\n// 需求场景1：\r\n// 以下是头秃写法的坑，为了解决这种顺序错乱的问题，要搞个栈做处理（先进后出，弹夹）\r\n// 原理：函数调用是是个栈型结构\r\n// effect(()=>{ // effect1\r\n//     state.name // => effect1\r\n//     effect(()=>{ // effect2\r\n//         state.age // => effect2\r\n//     })\r\n//     state.sex // 按逻辑应该是effect1，但是如果没有一个栈做处理，就会变成effect2了\r\n// })\r\n\r\n// 需求场景2：\r\n// 如果对于effect是否已入栈不检查，以下就会出现死循环\r\n// effect(()=>{\r\n//     state.xxx++\r\n// })\r\n","// 实现关键的Handelr，里面有get、有set\r\n\r\nimport { extend, isArray, isObject } from \"@vue/shared/src\";\r\nimport { track } from \"./effect\";\r\nimport { TrackOpTypes } from \"./operators\";\r\nimport { reactive, readonly } from \"./reactive\";\r\n\r\n// 考虑1：是不是仅读，仅读的属性set时会报异常\r\n// 考虑2：是不是深度\r\n\r\nlet readonlyObj = {\r\n  set: (target, key) => {\r\n    console.warn(`set on key  ${key} failed`);\r\n  },\r\n};\r\n\r\nconst get = createGetter();\r\nconst shallowGet = createGetter(false, true);\r\nconst readonlyGet = createGetter(true);\r\nconst shallowReadonlyGet = createGetter(true, true);\r\nconst set = createSetter();\r\nconst shallowSet = createSetter(true);\r\n\r\nconst mutableHandlers = {\r\n  get,\r\n};\r\n\r\nconst shallowReactiveHandlers = {\r\n  get: shallowGet,\r\n};\r\n\r\nconst readonlyHandlers = extend(\r\n  {\r\n    get: readonlyGet,\r\n  },\r\n  readonlyObj\r\n);\r\n\r\nconst shallowReadonlyHandlers = extend(\r\n  {\r\n    get: shallowReadonlyGet,\r\n  },\r\n  readonlyObj\r\n);\r\n\r\nexport {\r\n  mutableHandlers,\r\n  shallowReactiveHandlers,\r\n  readonlyHandlers,\r\n  shallowReadonlyHandlers,\r\n};\r\n\r\nfunction createGetter(isReadonly = false, isShallow = false) {\r\n  // 核心拦截方法\r\n  return function get(target, key, receiver) {\r\n    // let proxy = reactivee()\r\n    // proxy + reflect(后续obiect上的方法会被迁移到reflect)\r\n    // 在以前，target[key] = vlaue 可能会失败（如果target只读），并不会报异常，也没有返回值标识\r\n    // reflect方法具备返回值\r\n\r\n    const res = Reflect.get(target, key, receiver);\r\n\r\n    if(!isReadonly){\r\n        // 收集依赖，会等数据变化后更新对应的视图\r\n        console.log(\"收集effect\",new Date)\r\n        track(target,TrackOpTypes.GET,key) // TrackOpTypes.GET目前只是一个标识\r\n    }\r\n\r\n    if(isShallow){\r\n        return res\r\n    }\r\n\r\n    if(isObject(res)){ // vue2 是一上来就递归，vue3 是当取值时会进行代理。vue3的代理模式是懒代理。\r\n        return isReadonly ? readonly(res):reactive(res)\r\n    }\r\n\r\n    return res;\r\n  };\r\n}\r\nfunction createSetter(isShallow = false) {\r\n  // 核心设置方法\r\n  return function set(target, key, value, receiver) {\r\n    const res = Reflect.set(target, key, value, receiver);\r\n\r\n    // 当数据更新时，通知对应属性的effect重新执行\r\n\r\n    // 我们要区分是新增还是修改的。vue2里无法监控更改索引，无法监控数组长度变化；vue3都解决了。但其中还是有hack的方法，需要特殊处理。\r\n    const oldValue = target[key]; // 获取老的值\r\n\r\n\r\n\r\n    return res;\r\n  };\r\n}\r\n","import { isObject } from \"@vue/shared/src\"\r\nimport {\r\n    mutableHandlers,\r\n    shallowReactiveHandlers,\r\n    readonlyHandlers,\r\n    shallowReadonlyHandlers,\r\n} from './baseHandlers'\r\n\r\n\r\n\r\nexport function reactive(target) {\r\n    return createReactiveObject(target, false, mutableHandlers)\r\n}\r\nexport function shallowReactive(target) {\r\n    return createReactiveObject(target, false, shallowReactiveHandlers)\r\n}\r\nexport function readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers)\r\n}\r\nexport function shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers)\r\n}\r\n\r\n// 是不是只读，是不是深度。完全可以用参数配置，所以考虑柯里化，公用同一个方法（省的写四遍）\r\n// vue3响应式底层核心原理是：new Proxy  其本质还是操作get和set\r\nconst reactiveMap = new WeakMap(); // 会自动垃圾回收，不会造成内存泄露，存储的key只能是对象\r\nconst readonlyMap = new WeakMap();\r\nexport function createReactiveObject(target, isReadonly, baseHanelers) {\r\n    // 如果目标不是对象，没法拦截了，reactive这个api只能拦截对象类型\r\n    if (!isObject(target)) {\r\n        return target\r\n    }\r\n\r\n    // 如果某个对象已经被代理，就不要再次代理\r\n    const proxyMap = isReadonly ? readonlyMap : reactiveMap\r\n    const exisProxy = proxyMap.get(target)\r\n    if (exisProxy) {\r\n        return exisProxy\r\n    }\r\n    // 发现未被代理，那么代理一下，并存储到map里以备查询\r\n    const proxy = new Proxy(target, baseHanelers);\r\n    proxyMap.set(target, proxy) // 将要代理的对象和对应的代理结果缓存起来\r\n\r\n    return proxy;\r\n}\r\n"],"names":[],"mappings":"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"}