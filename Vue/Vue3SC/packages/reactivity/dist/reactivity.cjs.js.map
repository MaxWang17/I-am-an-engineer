{"version":3,"file":"reactivity.cjs.js","sources":["../../shared/src/index.ts","../src/effect.ts","../src/baseHandlers.ts","../src/reactive.ts"],"sourcesContent":["const isObject = (value)=> typeof value == 'object' && value !== null\r\nconst extend = Object.assign\r\n\r\nexport{\r\n    isObject,\r\n    extend\r\n}","export function effect(fn, options: any = {}) {\r\n  const effect = createReactiveEffect(fn, options);\r\n\r\n  if(!options.lazy){ // 利用配置的lazy属性\r\n      effect(); // 响应式的effect会默认先执行一次\r\n  }\r\n\r\n  return effect;\r\n}\r\n\r\n\r\n\r\nlet uid = 0\r\nlet activeEffect; // 存储当前正在运行的effect\r\nconst effectStack = [] // \r\nfunction createReactiveEffect(fn, options){\r\n    const effect = function reactiveEffect(){\r\n        if(!effectStack.includes(effect)){ // 保证effect不在栈里才执行\r\n            // 函数执行可能报错，所以用try-finally兜底一下\r\n            try{\r\n                effectStack.push(effect)\r\n                activeEffect = effect // 头秃写法\r\n                return fn() \r\n            }finally{ // 不管有无异常都执行\r\n                effectStack.pop()\r\n                activeEffect = effectStack[effectStack.length - 1]\r\n            }\r\n        }\r\n    }\r\n    effect.id = uid++ // 制作一个effect标识，用于区分effect\r\n    effect._isEffect = true // 用于标识这个是响应式effect\r\n    effect.row = fn // 保留effect对应的原函数\r\n    effect.options = options // 在effect上保存用户的属性\r\n    return effect\r\n}\r\n\r\n// 让，某个对象中的属性，收集当前它对应的effect\r\nexport function track(target,type,key){\r\n    activeEffect; // 关联已创建，你学废了吗\r\n}\r\n\r\n// 需求场景1：\r\n// 以下是头秃写法的坑，为了解决这种顺序错乱的问题，要搞个栈做处理（先进后出，弹夹）\r\n// 原理：函数调用是是个栈型结构\r\n// effect(()=>{ // effect1\r\n//     state.name // => effect1\r\n//     effect(()=>{ // effect2\r\n//         state.age // => effect2\r\n//     })\r\n//     state.sex // 按逻辑应该是effect1，但是如果没有一个栈做处理，就会变成effect2了\r\n// })\r\n\r\n// 需求场景2：\r\n// 如果对于effect是否已入栈不检查，以下就会出现死循环\r\n// effect(()=>{\r\n//     state.xxx++\r\n// })","// 实现关键的Handelr，里面有get、有set\r\n\r\nimport { extend, isObject } from \"@vue/shared/src\";\r\nimport { track } from \"./effect\";\r\nimport { TrackOpTypes } from \"./operators\";\r\nimport { reactive, readonly } from \"./reactive\";\r\n\r\n// 考虑1：是不是仅读，仅读的属性set时会报异常\r\n// 考虑2：是不是深度\r\n\r\nlet readonlyObj = {\r\n  set: (target, key) => {\r\n    console.warn(`set on key  ${key} failed`);\r\n  },\r\n};\r\n\r\nconst get = createGetter();\r\nconst shallowGet = createGetter(false, true);\r\nconst readonlyGet = createGetter(true);\r\nconst shallowReadonlyGet = createGetter(true, true);\r\nconst set = createSetter();\r\nconst shallowSet = createSetter(true);\r\n\r\nconst mutableHandlers = {\r\n  get,\r\n};\r\n\r\nconst shallowReactiveHandlers = {\r\n  get: shallowGet,\r\n};\r\n\r\nconst readonlyHandlers = extend(\r\n  {\r\n    get: readonlyGet,\r\n  },\r\n  readonlyObj\r\n);\r\n\r\nconst shallowReadonlyHandlers = extend(\r\n  {\r\n    get: shallowReadonlyGet,\r\n  },\r\n  readonlyObj\r\n);\r\n\r\nexport {\r\n  mutableHandlers,\r\n  shallowReactiveHandlers,\r\n  readonlyHandlers,\r\n  shallowReadonlyHandlers,\r\n};\r\n\r\nfunction createGetter(isReadonly = false, isShallow = false) {\r\n  // 核心拦截方法\r\n  return function get(target, key, receiver) {\r\n    // let proxy = reactivee()\r\n    // proxy + reflect(后续obiect上的方法会被迁移到reflect)\r\n    // 在以前，target[key] = vlaue 可能会失败（如果target只读），并不会报异常，也没有返回值标识\r\n    // reflect方法具备返回值\r\n\r\n    const res = Reflect.get(target, key, receiver);\r\n\r\n    if(!isReadonly){\r\n        // 收集依赖，会等数据变化后更新对应的视图\r\n        console.log(\"收集effect\",new Date)\r\n        track(target,TrackOpTypes.GET,key) // TrackOpTypes.GET目前只是一个标识\r\n    }\r\n\r\n    if(isShallow){\r\n        return res\r\n    }\r\n\r\n    if(isObject(res)){ // vue2 是一上来就递归，vue3 是当取值时会进行代理。vue3的代理模式是懒代理。\r\n        return isReadonly ? readonly(res):reactive(res)\r\n    }\r\n\r\n    return res;\r\n  };\r\n}\r\nfunction createSetter(isShallow = false) {\r\n  // 核心设置方法\r\n  return function set(target, key, value, receiver) {\r\n    const res = Reflect.set(target, key, value, receiver);\r\n\r\n    return res;\r\n  };\r\n}\r\n","import { isObject } from \"@vue/shared/src\"\r\nimport {\r\n    mutableHandlers,\r\n    shallowReactiveHandlers,\r\n    readonlyHandlers,\r\n    shallowReadonlyHandlers,\r\n} from './baseHandlers'\r\n\r\n\r\n\r\nexport function reactive(target) {\r\n    return createReactiveObject(target, false, mutableHandlers)\r\n}\r\nexport function shallowReactive(target) {\r\n    return createReactiveObject(target, false, shallowReactiveHandlers)\r\n}\r\nexport function readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers)\r\n}\r\nexport function shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers)\r\n}\r\n\r\n// 是不是只读，是不是深度。完全可以用参数配置，所以考虑柯里化，公用同一个方法（省的写四遍）\r\n// vue3响应式底层核心原理是：new Proxy  其本质还是操作get和set\r\nconst reactiveMap = new WeakMap(); // 会自动垃圾回收，不会造成内存泄露，存储的key只能是对象\r\nconst readonlyMap = new WeakMap();\r\nexport function createReactiveObject(target, isReadonly, baseHanelers) {\r\n    // 如果目标不是对象，没法拦截了，reactive这个api只能拦截对象类型\r\n    if (!isObject(target)) {\r\n        return target\r\n    }\r\n\r\n    // 如果某个对象已经被代理，就不要再次代理\r\n    const proxyMap = isReadonly ? readonlyMap : reactiveMap\r\n    const exisProxy = proxyMap.get(target)\r\n    if (exisProxy) {\r\n        return exisProxy\r\n    }\r\n    // 发现未被代理，那么代理一下，并存储到map里以备查询\r\n    const proxy = new Proxy(target, baseHanelers);\r\n    proxyMap.set(target, proxy) // 将要代理的对象和对应的代理结果缓存起来\r\n\r\n    return proxy;\r\n}\r\n"],"names":[],"mappings":"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"}