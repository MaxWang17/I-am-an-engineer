{"code":"export function effect(fn, options = {}) {\r\n    const effect = createReactiveEffect(fn, options);\r\n    if (!options.lazy) { // 利用配置的lazy属性\r\n        effect(); // 响应式的effect会默认先执行一次\r\n    }\r\n    return effect;\r\n}\r\nlet uid = 0;\r\nlet activeEffect; // 存储当前正在运行的effect\r\nconst effectStack = []; // \r\nfunction createReactiveEffect(fn, options) {\r\n    const effect = function reactiveEffect() {\r\n        if (!effectStack.includes(effect)) { // 保证effect不在栈里才执行\r\n            // 函数执行可能报错，所以用try-finally兜底一下\r\n            try {\r\n                effectStack.push(effect);\r\n                activeEffect = effect; // 头秃写法\r\n                return fn();\r\n            }\r\n            finally { // 不管有无异常都执行\r\n                effectStack.pop();\r\n                activeEffect = effectStack[effectStack.length - 1];\r\n            }\r\n        }\r\n    };\r\n    effect.id = uid++; // 制作一个effect标识，用于区分effect\r\n    effect._isEffect = true; // 用于标识这个是响应式effect\r\n    effect.row = fn; // 保留effect对应的原函数\r\n    effect.options = options; // 在effect上保存用户的属性\r\n    return effect;\r\n}\r\n// 让，某个对象中的属性，收集当前它对应的effect\r\nconst targetMap = new WeakMap();\r\nexport function track(target, type, key) {\r\n    // activeEffect; // 关联已创建，你学废了吗\r\n    if (activeEffect === undefined) { // 此属性不用收集依赖，因为没在effect中使用\r\n        return;\r\n    }\r\n    let depsMap = targetMap.get(target);\r\n    if (!depsMap) { //初次取值找不到\r\n        targetMap.set(target, (depsMap = new Map));\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if (!dep) {\r\n        depsMap.set(key, (dep = new Set));\r\n    }\r\n    if (!dep.has(activeEffect)) {\r\n        dep.add(activeEffect);\r\n    }\r\n}\r\n// 需求场景1：\r\n// 以下是头秃写法的坑，为了解决这种顺序错乱的问题，要搞个栈做处理（先进后出，弹夹）\r\n// 原理：函数调用是是个栈型结构\r\n// effect(()=>{ // effect1\r\n//     state.name // => effect1\r\n//     effect(()=>{ // effect2\r\n//         state.age // => effect2\r\n//     })\r\n//     state.sex // 按逻辑应该是effect1，但是如果没有一个栈做处理，就会变成effect2了\r\n// })\r\n// 需求场景2：\r\n// 如果对于effect是否已入栈不检查，以下就会出现死循环\r\n// effect(()=>{\r\n//     state.xxx++\r\n// })\r\n//# sourceMappingURL=effect.js.map","references":[],"map":"{\"version\":3,\"file\":\"effect.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../packages/reactivity/src/effect.ts\"],\"names\":[],\"mappings\":\"AAAA,MAAM,UAAU,MAAM,CAAC,EAAE,EAAE,UAAe,EAAE;IAC1C,MAAM,MAAM,GAAG,oBAAoB,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC;IAEjD,IAAG,CAAC,OAAO,CAAC,IAAI,EAAC,EAAE,cAAc;QAC7B,MAAM,EAAE,CAAC,CAAC,qBAAqB;KAClC;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AAID,IAAI,GAAG,GAAG,CAAC,CAAA;AACX,IAAI,YAAY,CAAC,CAAC,kBAAkB;AACpC,MAAM,WAAW,GAAG,EAAE,CAAA,CAAC,GAAG;AAC1B,SAAS,oBAAoB,CAAC,EAAE,EAAE,OAAO;IACrC,MAAM,MAAM,GAAG,SAAS,cAAc;QAClC,IAAG,CAAC,WAAW,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAC,EAAE,kBAAkB;YACjD,8BAA8B;YAC9B,IAAG;gBACC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;gBACxB,YAAY,GAAG,MAAM,CAAA,CAAC,OAAO;gBAC7B,OAAO,EAAE,EAAE,CAAA;aACd;oBAAO,EAAE,YAAY;gBAClB,WAAW,CAAC,GAAG,EAAE,CAAA;gBACjB,YAAY,GAAG,WAAW,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAA;aACrD;SACJ;IACL,CAAC,CAAA;IACD,MAAM,CAAC,EAAE,GAAG,GAAG,EAAE,CAAA,CAAC,0BAA0B;IAC5C,MAAM,CAAC,SAAS,GAAG,IAAI,CAAA,CAAC,mBAAmB;IAC3C,MAAM,CAAC,GAAG,GAAG,EAAE,CAAA,CAAC,iBAAiB;IACjC,MAAM,CAAC,OAAO,GAAG,OAAO,CAAA,CAAC,kBAAkB;IAC3C,OAAO,MAAM,CAAA;AACjB,CAAC;AAED,4BAA4B;AAC5B,MAAM,SAAS,GAAG,IAAI,OAAO,EAAE,CAAA;AAC/B,MAAM,UAAU,KAAK,CAAC,MAAM,EAAC,IAAI,EAAC,GAAG;IACjC,+BAA+B;IAC/B,IAAG,YAAY,KAAK,SAAS,EAAC,EAAE,0BAA0B;QACtD,OAAO;KACV;IACD,IAAI,OAAO,GAAI,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAA;IACpC,IAAG,CAAC,OAAO,EAAC,EAAE,SAAS;QACnB,SAAS,CAAC,GAAG,CAAC,MAAM,EAAC,CAAC,OAAO,GAAG,IAAI,GAAG,CAAC,CAAC,CAAA;KAC5C;IACD,IAAI,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAC3B,IAAG,CAAC,GAAG,EAAC;QACJ,OAAO,CAAC,GAAG,CAAC,GAAG,EAAC,CAAC,GAAG,GAAG,IAAI,GAAG,CAAC,CAAC,CAAA;KACnC;IACD,IAAG,CAAC,GAAG,CAAC,GAAG,CAAC,YAAY,CAAC,EAAC;QACtB,GAAG,CAAC,GAAG,CAAC,YAAY,CAAC,CAAA;KACxB;AACL,CAAC;AAED,SAAS;AACT,2CAA2C;AAC3C,iBAAiB;AACjB,0BAA0B;AAC1B,+BAA+B;AAC/B,8BAA8B;AAC9B,kCAAkC;AAClC,SAAS;AACT,2DAA2D;AAC3D,KAAK;AAEL,SAAS;AACT,+BAA+B;AAC/B,eAAe;AACf,kBAAkB;AAClB,KAAK\"}"}
