# 算法

[toc]



# 基本数据结构——数组

## 数组的创建

- 创建空数组`const arr = new Array()`

- 创建指定长度的空数组`const arr = new Array(7)`
- 创建指定长度，且有内容的数组`const arr = (new Array(7)).fill(1)`

## 数组的遍历

for就ok了（性能最快）。

## 二维数组

题干中，二维数组就是矩阵，矩阵就是二维数组。

## 二维数组初始化

for

## 二维数组的访问

二次循环。换句话来说，**N维数组需要N层循环来完成遍历**。

# 基本数据结构——栈和队列

## 数组的增删操作

push，unshift，splice......

### 栈（Stack）——只用 pop 和 push 完成增删的“数组”（压弹匣）

>  栈是一种后进先出(LIFO，Last In First Out)的数据结构。 
>
> - 只允许从尾部添加元素
> - 只允许从尾部取出元素
> - 栈顶元素：就是数组的尾部

### 队列（Queue）——只用 push 和 shift 完成增删的“数组”（排队取餐）

> 队列是一种先进先出（FIFO，First In First Out）的数据结构。 
>
>- 只允许从尾部添加元素
>- 只允许从头部移除元素
>- 队头元素：就是数组的第一个元素

## 链表

>  在链表中，每一个结点的结构都包括了两部分的内容：数据域和指针域。 
>
>  JS 中的链表，是以嵌套的对象的形式来实现的：

### 链表结点的创建

```javascript
function ListNode(){
    this.val = val
    this.next = null
}

const node = new ListNode(1)
node.next = new ListNode(2)

```

### 链表元素的添加（任意两个结点中插入一个新结点）

> 本质就是变更**前驱结点**和**目标结点**的next指针域

```javascript
// 如果目标结点本来不存在，那么记得手动创建
const node3 = new ListNode(3)     
// 把node3的 next 指针指向 node2（即 node1.next）
node3.next = node1.next
// 把node1的 next 指针指向 node3
node1.next = node3
```



### 链表元素的删除

> 【重中之重】定位目标结点的前驱结点

### 链表和数组的辨析

>-  链表的插入/删除效率较高，而访问效率较低； 
>-  数组的访问效率较高，而插入效率较低 

- JS中的数组不是"真正的数组"

  A: “存储在连续的内存空间里”是数组的必要条件。JS中纯数字数组还可满足此条件，但如果数组定义了不同类型元素（对象与数字共存）时，其底层使用哈希映射分配 内存空间，是由对象链表来实现的。

- “链表“的优点（也是数组的缺点）：**添加和删除元素都不需要挪动多余元素**

  A: 因为链表的增删操作，仅仅是改变目标结点及其前驱/后继结点的指针指向。而数组增删会改变往后所有元素的位置。

- “链表“的缺点（也是数组的优点）：**麻烦的访问操作**

  A: 我们试图读取一个特定的链表结点时，必须遍历整个链表来查找。数组可以直接访问索引，可以一步到位。

# 基本数据结构——树和二叉树

>名称解释：
>
>- 层：根结点所在层为第一层，子节点为第二层，以此类推。
>- 高度：叶子结点的高度记为1，每向上一层就加1。树中结点的最大高度，成为“树的高度”
>- 度：一个结点开叉多少个子结点，就是结点的“度”
>- 叶子结点：叶子结点就是度为0的结点。

> 理解二叉树
>
> - 二叉树不能被简单定义为每个结点的度都是2的树。二叉树的左右子树位置有严格约定，不可交换。

## 二叉树的编码实现

> 在 JS 中，二叉树使用对象来定义。它的结构分为三块：
>
> - 数据域
> - 左侧子结点（左子树根结点）的引用
> - 右侧子结点（右子树根结点）的引用

```javascript
function TreeNode(val){
    this.val = val;
    this.left = this.right = null;
}

const Node = new TreeNode(1)
```

## 【默写】二叉树递归遍历（先中后序）

>二叉树遍历方式有以下四种：
>
>- 先序遍历
>- 中序遍历
>- 后序遍历
>- 层次遍历
>
>按照实现方式的不同，遍历方式又可以分为以下两种：
>
>- 递归遍历（先、中、后序遍历）
>- 迭代遍历（层次遍历）



![二叉树基本结构](https://user-gold-cdn.xitu.io/2020/4/14/17177af5d863f478?imageslim)

在这三种顺序中，根结点的遍历分别被安排在了首要位置、中间位置和最后位置。

- 先序：根结点 => 左子树 => 右子树
- 中序：左子树 => 根结点 => 右子树
- 后序：左子树 => 右子树 => 根结点

编写一个递归函数之前，大家首先要明确两样东西：

- 递归式
- 递归边界

```javascript
const root = {
    val:"A",
    left:{
        val:'B',
        left:{
            val:'D'
        },
        right:{
            val:'E'
        }
    },
    right:{
        val:'C',
        right:{
            val:'F'
        }
    }
}

// 所有遍历函数的入参都是树的根结点对象
function preorder(root){
    // 递归边界
    if(!root) return

    // 输出当前遍历的节点值
    console.log('当前遍历的节点是：',root.val)
    // 递归遍历左子树
    preorder(root.left)
    // 递归遍历右子树 
    preorder(root.right)
}

// 所有遍历函数的入参都是树的根结点对象
function inorder(root) {
    // 递归边界，root 为空
    if(!root) {
        return 
    }
     
    // 递归遍历左子树 
    inorder(root.left)  
    // 输出当前遍历的结点值
    console.log('当前遍历的结点值是：', root.val)  
    // 递归遍历右子树  
    inorder(root.right)
}
function postorder(root) {
    // 递归边界，root 为空
    if(!root) {
        return 
    }
     
    // 递归遍历左子树 
    postorder(root.left)  
    // 递归遍历右子树  
    postorder(root.right)
    // 输出当前遍历的结点值
    console.log('当前遍历的结点值是：', root.val)  
}
```

# 算法的衡量——时间复杂度与空间复杂度

# 数组的应用——基础篇

## Map 的妙用——两数求和问题

> 真题描述： 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

> 示例:
>
> 给定 nums = [2, 7, 11, 15], target = 9
> 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]

### 思路提点

1. 【空间换时间】：算法考察中，主要侧重时间复杂度
2. 【求和类型题锦囊】：几乎大多数求和，都可以转变为**求差**

## 双指针——合并两个有序数组

> 真题描述：给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。

说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。

> 示例:

输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6], n = 3
输出: [1,2,2,3,5,6]

### 思路提点

1.  标准解法就是双指针法 ： **每次只对指针所指的元素进行比较** 

## 双指针之对撞法——三数求和问题

> 真题描述：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

> 示例：

给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]

### 思路提点

1. 依然可以把求和转化为求差
2. 双指针对撞法：必须有序。若题干中没有排序，正所谓【没有条件，创造条件】，手动排序即可。
3. 