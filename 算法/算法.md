# 算法

[toc]



# 基本数据结构——数组

## 数组的创建

- 创建空数组`const arr = new Array()`

- 创建指定长度的空数组`const arr = new Array(7)`
- 创建指定长度，且有内容的数组`const arr = (new Array(7)).fill(1)`

## 数组的遍历

for就ok了（性能最快）。

## 二维数组

题干中，二维数组就是矩阵，矩阵就是二维数组。

## 二维数组初始化

for

## 二维数组的访问

二次循环。换句话来说，**N维数组需要N层循环来完成遍历**。

# 基本数据结构——栈和队列

## 数组的增删操作

push，unshift，splice......

### 栈（Stack）——只用 pop 和 push 完成增删的“数组”（压弹匣）

>  栈是一种后进先出(LIFO，Last In First Out)的数据结构。 
>
> - 只允许从尾部添加元素
> - 只允许从尾部取出元素
> - 栈顶元素：就是数组的尾部

### 队列（Queue）——只用 push 和 shift 完成增删的“数组”（排队取餐）

> 队列是一种先进先出（FIFO，First In First Out）的数据结构。 
>
>- 只允许从尾部添加元素
>- 只允许从头部移除元素
>- 队头元素：就是数组的第一个元素

## 链表

>  在链表中，每一个结点的结构都包括了两部分的内容：数据域和指针域。 
>
>  JS 中的链表，是以嵌套的对象的形式来实现的：

### 链表结点的创建

```javascript
function ListNode(){
    this.val = val
    this.next = null
}

const node = new ListNode(1)
node.next = new ListNode(2)

```

### 链表元素的添加（任意两个结点中插入一个新结点）

> 本质就是变更**前驱结点**和**目标结点**的next指针域

```javascript
// 如果目标结点本来不存在，那么记得手动创建
const node3 = new ListNode(3)     
// 把node3的 next 指针指向 node2（即 node1.next）
node3.next = node1.next
// 把node1的 next 指针指向 node3
node1.next = node3
```



### 链表元素的删除

> 【重中之重】定位目标结点的前驱结点

### 链表和数组的辨析

>-  链表的插入/删除效率较高，而访问效率较低； 
>-  数组的访问效率较高，而插入效率较低 

- JS中的数组不是"真正的数组"

  A: “存储在连续的内存空间里”是数组的必要条件。JS中纯数字数组还可满足此条件，但如果数组定义了不同类型元素（对象与数字共存）时，其底层使用哈希映射分配 内存空间，是由对象链表来实现的。

- “链表“的优点（也是数组的缺点）：**添加和删除元素都不需要挪动多余元素**

  A: 因为链表的增删操作，仅仅是改变目标结点及其前驱/后继结点的指针指向。而数组增删会改变往后所有元素的位置。

- “链表“的缺点（也是数组的优点）：**麻烦的访问操作**

  A: 我们试图读取一个特定的链表结点时，必须遍历整个链表来查找。数组可以直接访问索引，可以一步到位。

# 基本数据结构——树和二叉树

>名称解释：
>
>- 层：根结点所在层为第一层，子节点为第二层，以此类推。
>- 高度：叶子结点的高度记为1，每向上一层就加1。树中结点的最大高度，成为“树的高度”
>- 度：一个结点开叉多少个子结点，就是结点的“度”
>- 叶子结点：叶子结点就是度为0的结点。

> 理解二叉树
>
> - 二叉树不能被简单定义为每个结点的度都是2的树。二叉树的左右子树位置有严格约定，不可交换。

## 二叉树的编码实现

> 在 JS 中，二叉树使用对象来定义。它的结构分为三块：
>
> - 数据域
> - 左侧子结点（左子树根结点）的引用
> - 右侧子结点（右子树根结点）的引用

```javascript
function TreeNode(val){
    this.val = val;
    this.left = this.right = null;
}

const Node = new TreeNode(1)
```

## 【默写】二叉树递归遍历（先中后序）

>二叉树遍历方式有以下四种：
>
>- 先序遍历
>- 中序遍历
>- 后序遍历
>- 层次遍历
>
>按照实现方式的不同，遍历方式又可以分为以下两种：
>
>- 递归遍历（先、中、后序遍历）
>- 迭代遍历（层次遍历）



![二叉树基本结构](https://user-gold-cdn.xitu.io/2020/4/14/17177af5d863f478?imageslim)

在这三种顺序中，根结点的遍历分别被安排在了首要位置、中间位置和最后位置。

- 先序：根结点 => 左子树 => 右子树
- 中序：左子树 => 根结点 => 右子树
- 后序：左子树 => 右子树 => 根结点

编写一个递归函数之前，大家首先要明确两样东西：

- 递归式
- 递归边界

```javascript
const root = {
    val:"A",
    left:{
        val:'B',
        left:{
            val:'D'
        },
        right:{
            val:'E'
        }
    },
    right:{
        val:'C',
        right:{
            val:'F'
        }
    }
}

// 所有遍历函数的入参都是树的根结点对象
function preorder(root){
    // 递归边界
    if(!root) return

    // 输出当前遍历的节点值
    console.log('当前遍历的节点是：',root.val)
    // 递归遍历左子树
    preorder(root.left)
    // 递归遍历右子树 
    preorder(root.right)
}

// 所有遍历函数的入参都是树的根结点对象
function inorder(root) {
    // 递归边界，root 为空
    if(!root) {
        return 
    }
     
    // 递归遍历左子树 
    inorder(root.left)  
    // 输出当前遍历的结点值
    console.log('当前遍历的结点值是：', root.val)  
    // 递归遍历右子树  
    inorder(root.right)
}
function postorder(root) {
    // 递归边界，root 为空
    if(!root) {
        return 
    }
     
    // 递归遍历左子树 
    postorder(root.left)  
    // 递归遍历右子树  
    postorder(root.right)
    // 输出当前遍历的结点值
    console.log('当前遍历的结点值是：', root.val)  
}
```

